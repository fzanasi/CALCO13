\documentclass{llncs}

\include{macros}

\begin{document}
\title{Coalgebraic Semantics for Logic Programming via Saturation}

\maketitle
\abstract{TODO}


\section{Introduction}

In \cite{KomMcCuskerPowerAMAST10} Komendantskaya, McCusker and Power introduced a coalgebraic semantics for ground logic programs. These are the programs where only atomic formulae without variables (also called \emph{ground atoms}) can occur in the clauses. Fixed such a set $\At$ of ground atoms, a given program $\mb{P}$ can encoded as a coalgebra $p : \At \to \p_f \p_f (\At)$ on $\Set$, where $\p _f$ is the finite powerset functor. The idea is that each atom $A \in \At$, now considered as a \emph{goal}, is associated with the set $p(A)$ where each element corresponds to a clause $H :- B_1,\dots,B_k$ of $\mb{P}$ whose head $H$ \emph{unifies with} $A$, i.e. (in the ground case) $H = A$. Each such element is itself a set, consisting of the atoms $B_1,\dots, B_k$ in the body of the clause.

\begin{example} A program $\mb{P}$, the associated coalgebra and the value on an atom $A$.

\end{example}

The main result of \cite{KomMcCuskerPowerAMAST10} concerns the construction of a coalgebra $\overline{p} \: \At \to \mb{C}(\p _f \p _f)(\At)$, where $\mb{C}(\p _f \p _f)$ is the \emph{cofree comonad} on $\p_f \p_f$. The set $\mb{C}(\p _f \p _f)(\At)$ is obtained as the convergence point of the terminal sequence for the functor $\At \times \p_f \p_f (-)$. As the elements of the cofree comonad on $\p_f$ are standardly presented as finitely branching trees \cite{Worrell99}, we can depict elements of $\mb{C}(\p _f \p _f)$ as finitely branching trees with two sorts of nodes - corresponding to the $\p _f \p _f (-)$ component of the functor - with labels on one of the two sorts - corresponding to the $\At \times -$ component.

Given an atomic goal $A \in \At$, the tree $\overline{p}(A) \in \mb{C}(\p _f \p _f)(\At)$ is built by iteratively applying the map $p$, first to $A$, then to each atom in $p(A)$, and so on. Each iteration $n < \omega$ corresponds to the extension to depth $n$ of the previously constructed tree of depth $n-1$. The resulting object $\overline{p}(A)$ can be depicted as the \emph{parallel and-or tree} for $A$, where the two sorts of nodes are called \emph{and-nodes} and \emph{or-nodes}.

\begin{definition}\label{DEF:and-or_par_tree_ground} Parallel and-or tree

\end{definition}

The main intuition is that the tree $\overline{p}(A)$ represents the graph of all possible \emph{and-or parallel} derivation strategies for solving the atomic goal $A$ in the program $\mb{P}$. Parallelism in logic programming arises in (at least) two forms:
\begin{itemize}
  \item \emph{or-parallelism} can be exploited when a given atomic goal $A$ matches the head of more than one clause in the program. Each such clause represents an alternative way of continuing the derivation associated with $A$, which can be explored in parallel.
      % For instance, if $A$ matches $H_1, \dots, H_k$ for clauses $H_1 :- B_1^1,\dots,B_n^1$, $\dots$, $H_n :- B_1^k \dots, B_m^k$, then an or-parallel strategy would split into derivation strategies $f_1, \dots, f_k$, each strategy $f_i$ trying to solve goals $B_1^i,\dots B_l^i$.
  \item \emph{And-parallelism} arises when the given goal consists of multiple atoms $B_1,\dots,B_n$ and we simultaneously look for a derivation of each subgoal $B_i$
     %strategies $f_1,\dots,f_n$, one for each $B_j$, proceed in parallel
      \footnote{In the general case, the atoms $B_1,\dots,B_n$ possibly contain and share variables - in this situation and-parallelism is tricky and may lead to an unsound derivation if no synchronization mechanism between $B_1,\dots,B_n$ is implemented. In the ground case that we consider here, $B_1,\dots,B_k$ do not contain variables, meaning that and-parallel derivation strategies are always sound.}.
\end{itemize}

In $\overline{p}(A)$, or-parallelism is represented explicitly by the presence of or-nodes. If they are siblings of the same and-node labeled with an atom $A$, multiple or-nodes represent multiple clauses whose head unifies with $A$. On the other hand, and-nodes gives a representation of and-parallelism: multiple and-nodes children of the same or-node represent atoms in the body of same clause, whose proof-search is executed in parallel.

\begin{example} Same $A$, $\mb{P}$ of the first example. Representation of $\overline{p}(A)$ as a tree.
\end{example}

The framework is extended in \cite{KomPowCALCO11} to arbitrary logic programs. Differently from the ground case, the presence of variables requires $p^{\sharp}$ to deal with \emph{substitution instances} of atoms. On the other hand, we want to maintain the primary feature of the base case, which is the explicit and-or parallelism exhibited by the notion of derivation tree associated with the coalgebra $p$. In this aim, a natural way to generalize and-or parallel trees (definition \ref{Def:AndOrParTrees_Prop}) to non-ground atoms is the following \cite{GuptaBMSM07}.

\begin{definition} And-Or tree

\end{definition}

\fabio{Is the associated coalgebra a natural transformation?}

Unfortunately, and-or trees are not guaranteed to represent sound derivations. The problem lies in the presence of variable dependencies and the use of unification, which make derivations for logic programs inherently \emph{sequential} processes \cite{MitchellSeqUnification}.

\begin{example} The LIST program and the goal $\m{List}(\m{cons}(x,\m{cons}(y,x)))$.

\end{example}

Komendantskaya and Power \cite{KomPowCALCO11} obviate to this difficulty by shaping a variant of and-or trees - called \emph{coinductive} derivation trees - where unification is restricted to the case of \emph{term matching}. Contrary to unification, the term-matching algorithm is parallelizable \cite{MitchellSeqUnification}. The intuitive reason is that, at each stage of the computation, we consider only the substitutions that do not modify the current goal, meaning that also the ``previous history'' of the computation remains uncorrupted. It turns out that coinductive trees only represent sound derivations.

\begin{definition}\label{Def:coinductive_trees_Power} Coinductive derivation tree

\end{definition}

Atoms possibly contain variables can be modeled as elements of a presheaf $\At \: \Lw \to \Set$, extending the set $\At$ considered in the base case, where $\Lw$ is the \emph{Lawvere theory} associated with a signature $\Sigma$ of function symbols. For each natural number $n$, the set $\At(n)$ consists of the atoms with at most $n$ distinct variables. As for the ground case, we would like to model the semantics by a coalgebra for the cofree comonad $\mb{C}(\F)$, where $\F$ is a suitable functor modeling the behavior of arbitrary logic programs, the same role played by $\p_f \p_f \: \Set \to \Set$ in the ground case. For this purpose, a natural suggestion would be to take as $\F$ the endofunctor $\widehat{\p_f}\widehat{\p_f}\: \prsh{\Lw} \to \prsh{\Lw}$, obtained by lifting $\p_f \p_f$ to the category of $\Lw$-indexed presheaves. Modulo a replacement of the first finite powerset functor $\p_f$ with the countable powerset functor $\p_c$, then we could model an arbitrary logic program $\mb{P}$ as the coalgebra $p^{\sharp} \: \At \to \PP (\At)$ which takes an atomic formula $A$ with at most $n$ distinct variables, consider all (countably many) substitution instances of clauses in $\mb{P}$ whose head agrees with $A$, and gives the set of sets of atoms in their bodies, analogously to the specification for ground logic programs.

As observed in \cite{KomPowCALCO11}, the problem with this formalization is that $p^{\sharp}$ is \emph{not} a natural transformation (i.e. an arrow $\prsh{\Lw}$), as shown by the following example.

\begin{example}\label{Ex:non_compositional} The LIST program, the two goals $\m{List}(x)$, $\m{List}(\m{Nil})$ and the substitution ${x\mapsto \m{Nil}}$.

\end{example}

The authors of \cite{KomPowCALCO11} overcome this difficulty by relaxing the naturality requirement. The presheaf $\At$, functors $\widehat{\p_c}$ and $\widehat{\p_f}$ are extended to act as a $\m{Poset}$-valued functors and $p^{\sharp}$ as a \emph{lax natural transformation}, all `living' in the category $\m{Lax}(\Lw,\m{Poset})$ of locally ordered functors $\F \: \Lw \to \m{Poset}$ and lax natural transformations. This approach supplies a coalgebra for the cofree comonad $\mb{C}(\widehat{\p_c}\widehat{\p_f})$ behaving according to the specification given above. However, it has also introduce several shortcomings. Unlike $\Set$ and $\prsh{\Lw}$, the category $\m{Lax}(\Lw,\m{Poset})$ is neither complete nor cocomplete, meaning that $\mb{C}(\widehat{\p_c}\widehat{\p_f})$ cannot be explicitly constructed through the standard terminal sequence method that was used in the ground case. Moreover, the category of $\widetilde{\p_c}\widetilde{\p_c}$-coalgebrae becomes problematic, because the commutativity property of coalgebra maps does not cohere well with the laxness of arrows in $\m{Lax}(\Lw,\m{Poset})$. These two issues force the formalization of non-ground logic program to use quite different (and more sophisticated) categorical tools than the ones employed for the ground case.

Even more significantly, the lax coalgebra map $p^{\sharp}$ induces a semantics which is not \emph{compositional}. The same square of example \ref{Ex:non_compositional} still does not commute in the lax setting, meaning that the actions of applying a substitution and making a derivation step produce different results according to the order in which we perform them.

On the base of this motivation, we propose a different approach to the semantics of arbitrary logic programs, based on \emph{saturation} techniques [CIT,CIT]. In our terminology, saturating an atom means to take all its (also non-ground) substitution instances. The term-matching approach in \cite{KomPowCALCO11} only operates a saturation on the program side, by trying to match a given goal with all possible substitution instances of heads in the program. What we suggest is to saturate also on the goal side, and shift the term matching to a correspondence between substitution instances of the goal and substitution instances of heads in the program.

$$\xymatrix{ \text{Atom A} \ar[d]^{\m{saturation}} & & \ar[d]^{saturation} \text{Heads in the program} \\
 \text{subst. instances of A} & & \ar@{<->}[ll]^-{\text{term-matching}} \text{subst. instances of heads} }$$

This approach enjoys an elegant categorical formulation in terms of \emph{Right Kan Extension} of $\K (\widetilde{\p_c}\widetilde{\p_c})$ the functor $\widetilde{\p_c}\widetilde{\p_c}$, now defined in the category $\prsh{|\Lw|}$ of presheaves indexed by the discrete category $|\Lw|$.

TODO

TODO

TODO

TODO

\section{Coalgebraic Semantics for Logic Programming}

In this section we recall the coalgebraic framework for logic programming, as introduced in \cite{KomMcCuskerPowerAMAST10} for the ground case and in \cite{KomPowerCSL11}, \cite{KomPowCALCO11} for the general case.

For this purpose, first we fix some terminology and notation.

XXXX

\pippo{La notazioen deve essere uniforme. Ad esempio o sempre $\K \F$ o sempre $\K(\F)$.}
\pippo{Usiamo ``arrows'' e ``objects'' solo per $\catC$. Per tutte le altre categorie, usiamo la loro definizione concreta,
ad esmepio in $\set$ usiamo ``function'' e ``sets'' e in $\prsh{\catC}$ ``presheaves'' e ``natural transformation''}
\pippo{Io userei $F$ e $G$ per i presheaves e non $\F$ e $\G$}
\pippo{Pure i predicati hanno una arieta': formano una segnatura. Pertanto e' impreciso dire che prendiamo un insieme di predicati.}
\fabio{Seguo la convenzione di Power di tenere distinta una segnatura $\Sigma$ di simboli per fuzione ed una segnatura (senza notazione) di simboli per predicati. In questo modo la Lawvere Theory e' definita solo in termini di $\Sigma$.}

Given a category $\catC$, we denote with $|\catC|$ the category with the same objects as $\catC$ but no arrows apart the identities. With a little abuse of notation, we also write $o \in |\catC|$ to indicate that $o$ is an object of $\catC$. If $\catC$ is small, the set of arrows from $o_1$ to $o_2$, with $o_1, o_2 \in |\catC|$, is denoted with $\catC [o_1,o_2]$. A $\catC$-indexed presheaf is any functor $\G$ of type $\catC \to \Set$. We indicate with $\prsh{\catC}$ the category of $\catC$-indexed presheaves and natural transformations between them.
Given an endofunctor $\F \: \catC \to \catC$, an $\F$-coalgebra on an object $o \in |\catC|$ is any arrow $p \: o \to \F (o)$. We denote with $\coalg{\F}$ the category of $\F$-coalgebrae and coalgebra morphisms \fabio{def of coalg.morphism needed?}.


For our purposes a \emph{signature} $\Sigma$ is a set of function symbols $f,g,h,\dots$ each equipped with a fixed arity. Given a countably infinite list $\m{Var} = \{x_1,x_2,x_3,\dots\}$ of variables, we define the set $\Ter{\Sigma}$ of \emph{terms} over $\Sigma$ and $\Var$ as expected. The Lawvere Theory associated with $\Sigma$ and $\m{Var}$ is a category $\Lw$ where objects are natural numbers, with $n \in |\Lw|$ representing variables $x_1,x_2,\dots,x_n$ from $\m{Var}$. Given $n,m \in |\Lw|$, the set $\Lw [n,m]$ consists of all $m$-tuples $<t_1,\dots,t_m>$ of terms from $\Ter{\Sigma}$ where only variables among $x_1,x_2,\dots,x_n$ occur. In some context we also call \emph{substitutions} the arrows of $\Lw$ and use Greek letters $\theta,\sigma, \tau, \dots$ for them. Given a substitution $\theta = <t_1,\dots,t_m> \: n \to m$, an atom the result of applying a substitution $\theta$ to $A$ is denoted with $A \theta$. We can identify arrows in $\Lw$ with \emph{substitutions} $\theta: \Var \to \Ter{\Sigma}$ that is the identity on all but finitely many variables. We use Greek letters $\theta,\sigma, \tau, \dots$ to denote substitutions.
An \emph{alphabet} consists of a signature $\Sigma$ a list of variables $\m{Var}$ and a set of predicate symbols $P, P_1, P_2,\dots$ each assigned an arity. Given a predicate symbol $P$ of arity $n$ and terms $t_1,\dots,t_n$, $P(t_1,\dots,t_n)$ is a \emph{formula} (also called an \emph{atom}). We use Latin capital letters $A,B,\dots$ for atoms and the notation $A(x_1,\dots,x_n)$ to indicate that the variables $x_1,\dots,x_n$ occur in the atom $A$. The set $\At$ consists of all atoms constructed from the symbols of the alphabet. Given a substitution $\theta = <t_1,\dots,t_m> \: n \to m$ and an atom $A(x_1,\dots,x_n)$, we denote with $A \theta$ the atom obtained by replacing $x_i$ with $t_i$ for each $i \leq m$. We use the notation $\{A_1,\dots,A_n\}\theta$ as a shorthand for $\{A_1\theta,\dots,A_n\theta\}$.

\subsection{The Ground Case}

We recall the modeling of variable-free programs through coalgebrae, as first presented in \cite{KomMcCuskerPowerAMAST10}. Given a set $\At$ of ground formulae, let $\mb{P}$ be a logic program with clauses given by atoms from $\At$. The behavior represented by $\mb{P}$ is captured by a coalgebra $p \: \At \to \p_f \p_f (\At)$, which is defined as follows:
\begin{eqnarray}\label{Eq:def_coalg_p}
% \nonumber to remove numbering (before each equation)
  \nonumber
  p \: \ A\ \mapsto\ \{\{B_1,\dots,B_n\} & \mid & H :- B_1,\dots,B_n \text{ is a clause of }\mb{P} \\
                                         &      & \text{ and }A = H\}.
\end{eqnarray}

\begin{proposition} For any set $\At$, there is a bijection between the set of ground logic programs over $\At$ and the set of $\p_f \p_f$-coalgebra structures on $\At$.
\end{proposition}

Given an atomic goal $A \in \At$, the parallel and-or derivation tree (definition \ref{DEF:and-or_par_tree_ground}) for $A$ in $\mb{P}$ can be recovered by iteratively applying the action of the coalgebra $p$, where each iteration intuitively represents a single derivation step. Categorically, this is modeled as the terminal sequence \cite{Worrell99} leading the cofree $\p_f \p_f$-coalgebra on $\At$.

\begin{construction}\label{Constr:cofree_ground} The terminal sequence for the functor $\At \times \p_f \p_f (-) \: \Set \to \Set$ consists of the following sequence of objects $X_{\alpha}$ and arrows $\delta_{\alpha}\: X_{\alpha+1} \to X_{\alpha}$, defined by induction on $\alpha$.
\fabio{Intuizione: oggetti di $X_{\alpha}$ sono alberi and-or (la componenete $\FS$) dove i nodi and sono etichettati con elementi di $\At$ (la componente $\At$).}
\begin{eqnarray*}
 % \nonumber to remove numbering (before each equation)
   X_{\alpha} &:=& \left\{
	\begin{array}{ll}
        \At & \alpha = 0 \\
		\At \times \p_f \p_f (X_{\beta}) & \alpha \mbox{ is a successor ordinal } \beta +1
        % \\  \m{Lim}_{\beta \ls \alpha}\ X_{\beta} & \alpha \mbox{ is a limit ordinal}
	\end{array}
\right.\\
  \delta_{\alpha} &:=& \left\{
	\begin{array}{ll}
        \pi_1 & \alpha = 0 \\
		\m{Id}_{\At} \times \p_f \p_f (\delta_{\beta}) & \alpha \mbox{ is a successor ordinal } \beta +1
	\end{array}
\right.\\
 \end{eqnarray*}
For $\alpha$ a limit ordinal, $X_{\alpha}$ is given as a limit of the sequence and a function
$\delta_{\alpha}\: X_{\alpha} \to X_{\beta}$ is given for each $\beta \ls \alpha$ by universal mapping property of $X_{\alpha}$.

Both $\p _c$ and $\p _f$ are readily seen to be mono-preserving accessible functors. Then by theorem \cite[Th. 7]{Worrell99} we know that the sequence given above converges to a limit $X_{\gamma}$ such that $X_{\gamma} \cong X_{\gamma+1}$. Since $X_{\gamma+1}$ is defined as $\At \times \p_f \p_f X_{\gamma}$, there is a projection function $\pi_2 \: X_{\gamma +1} \to \p_f \p_f X_{\gamma}$ which makes $\pi_2 \circ \delta^{-1}_{\gamma} \:  X_{\gamma} \to \p_f \p_f X_{\gamma}$ the \emph{cofree $\p_f \p_f$-coalgebra} on $\At$.
\end{construction}

Elements of the terminal coalgebra for $\p_f$ are standardly presented as finitely branching trees \cite{Worrell99}. Along the same line of reasoning, we can depict elements of the terminal $\p_f\p_f$-coalgebra as finitely branching trees with two sorts of nodes - \emph{and-nodes} and \emph{or-nodes} - corresponding respectively to the action of the inner and the outer finite powerset functor. Then the terminal coalgebra for $\At \times \p_f \p_f (-)$ as in construction \ref{Constr:cofree_ground} can be depicted as the set of two-sorted finitely branching trees where and-nodes are labeled with atoms $A \in \At$.

This means that and-or parallel trees of definition \ref{Def:AndOrParTrees_Prop} are also elements of the carrier $X_{\gamma}$ of the cofree $\p_f \p_f$-coalgebra on $\At$. The next step is to supply a map $\overline{p} \: \At \to X_{\gamma}$ associating to every atomic goal $A$ its and-or parallel tree, defined according to a given logic program, i.e. a $\p_f\p_f$-coalgebra $p$. For such purpose, first observe that, since $\p_f \p_f$ is accessible, the functor $\FR \: \Set \to \coalg{\p_f \p_f}$ sending a set to its cofree $\p_f \p_f$-coalgebra is right adjoint to the forgetful functor $\V \: \coalg{\p_f \p_f} \to \Set$. Then $\V\FR \: \Set \to \Set$ is the \emph{cofree comonad} on $\p_f \p_f$, which we denote with $\mb{C}(\p_f \p_f)$. The map $\overline{p}$ is modeled as a $\mb{C}(\p_f \p_f)$-coalgebra $\At \to \mb{C}(\p_f \p_f)(\At) = X_{\gamma}$, which is constructed as follows.

\begin{construction}\label{Constr:coalgComonad_ground} Let $\{p_{\alpha}\: \At \to X_{\alpha}\}_{\alpha \ls \gamma}$ be a cone on the terminal sequence of construction \ref{Constr:cofree_ground}, given as:
\begin{eqnarray*}
 % \nonumber to remove numbering (before each equation)
   p_{\alpha} &:=& \left\{
	\begin{array}{ll}
        \m{Id}_{\At} & \alpha = 0 \\
		\m{Id}_{\At} \times ((\p_f \p_f  (p_{\beta}) \circ p) & \alpha \mbox{ is a successor ordinal } \beta +1
        % \\  \m{Lim}_{\beta \ls \alpha}\ X_{\beta} & \alpha \mbox{ is a limit ordinal}
	\end{array}
\right.\\
\end{eqnarray*}
For $\alpha$ a limit ordinal, a function $p_{\alpha}\: \At \to X_{\alpha}$ is provided by the universal mapping property of the limit $X_{\alpha}$. Then in particular $X_{\gamma} = \mb{C}(\p_f \p_f)(\At)$ yields a function $\overline{p}\: \At \to X_{\gamma}$ which is a $\mb{C}(\p_f \p_f)$-coalgebra structure on $\At$.
\end{construction}

Given an atomic goal $A \in \At$, for each $m \ls \omega$, the arrow $p_{m}$ can be described as the mapping of $A$ into its parallel and-or derivation tree up to depth $m$. Then the limit $\overline{p}$ of all such approximations maps $A$ into its parallel and-or derivation tree.

\begin{proposition} Given a set $\At$, an atom $A \in \At$ and a logic program $\mb{P}$, let $\overline{p}$ be defined according to construction \ref{Constr:coalgComonad_ground}. The value $\overline{p}(A)$ represents the parallel and-or derivation tree of $A$ from $\mb{P}$.
\end{proposition}

\subsection{The General Case}

The next step is to characterize a notion of behavior $p^{\sharp}\: \At \to \F \At$ allowing to encode arbitrary logic programs (possibly based on non-ground atoms) as $\F$-coalgebrae. Differently from the ground case, the presence of variables requires $p^{\sharp}$ to deal with \emph{substitution instances} of atoms. On the other hand, we want to maintain the primary feature of the base case, which is the explicit and-or parallelism exhibited by the notion of derivation tree associated with the coalgebra $p$. In this aim, a natural way to generalize and-or parallel trees (definition \ref{Def:AndOrParTrees_Prop}) to non-ground atoms is the following \cite{GuptaBMSM07}.

\begin{definition} And-Or tree

\end{definition}

\fabio{Is the associated coalgebra a natural transformation?}

Unfortunately, and-or trees are not guaranteed to represent sound derivations. The problem lies in the presence of variable dependencies and the use of unification, which make derivations for logic programs inherently \emph{sequential} processes \cite{MitchellSeqUnification}.

\begin{example} The LIST program and the goal $\m{List}(\m{cons}(x,\m{cons}(y,x)))$.

\end{example}

Komendantskaya and Power \cite{KomPowCALCO11} \cite{KomPowerCSL11} obviate to this difficulty by shaping a variant of and-or trees - called \emph{coinductive} derivation trees - where unification is restricted to the case of \emph{term matching}. Contrary to unification, the term-matching algorithm is parallelizable \cite{MitchellSeqUnification}. The intuitive reason is that, at each stage of the computation, we consider only the substitutions that do not modify the current goal, meaning that also the ``previous history'' of the computation remains uncorrupted. It turns out that coinductive trees only represent sound derivations.

\begin{definition}\label{Def:coinductive_trees_Power} Coinductive derivation tree

\end{definition}

We now recall from \cite{KomPowCALCO11} the categorical formalization of this class of trees, extending the framework already provided for the base case. A collection of (possibly not ground) atoms $\At$ is now modeled as a set with explicit annotation of variables, that is, as a presheaf having as index category the (contravariant) \emph{Lawvere Theory} $\Lw$ associated with the signature $\Sigma$. This is a category having having natural numbers as objects and arrows ${\mathcal{L}_{\Sigma}} (n,m)$ given by $m$-tuples $<t_1,\dots t_m>$ of terms in $\Ter{\Sigma}$ with at most $n$ distinct variables.

The presheaf $\At \: \Lw \to \Set$ (for which we overload the notation $\At \in |\Set|$ used in the base case) is then defined as follows. For each natural number $n \in |\Lw|$, $\At (n)$ is the set of atoms with at most $n$ distinct variables. Given an arrow $<t_1,\dots,t_n> \in \Lw(n,m)$, the function $\At(<t_1,\dots,t_n>)\: \At(n) \to \At(m)$ is defined by substitution, i.e.
\begin{eqnarray*}
% \nonumber to remove numbering (before each equation)
\At(<t_1,\dots,t_n>) & : & A(x_1,\dots,x_n) \mapsto A[t_1 \backslash x_1, \dots, t_n \backslash x_n]
\end{eqnarray*}
where $x_1,\dots,x_n$ are distinct variables occurring in $A(x_1,\dots,x_n)$ and $A[t_1 \backslash x_1, \dots, t_n \backslash x_n]$ denotes the atom obtained by substituting $x_1$ with $t_1$, $\dots$, $x_n$ with $t_n$ in $A(x_1,\dots,x_n)$.

Following the specification provided by definition \ref{Def:coinductive_trees_Power}, we want to model a notion of behavior acting as follows on atoms $A \in \At(n)$:
 \begin{eqnarray}\label{Eq:KomPow_termMatching}
    \nonumber
    A\ \mapsto\ \{ \{B_1,\dots,B_k\}\sigma & \mid & H :- B_1,\dots,B_k \text{ is a clause of }\mb{P}\\
                                         &      &   \text{and }A = \sigma (H)\}.
 \end{eqnarray}
%The above equation defines a function $p^{\sharp} \: \At(n) \to \p_c \p_f \At(n)$, where $n$ is the highest number of distinct variables
For each clause $H :- B_1,\dots,B_k$, there are infinitely (but countably) many substitutions $\sigma$ such that $A = \sigma (H)$. Thus the object on the right-hand side of \eqref{Eq:KomPow_termMatching} will be associated with the functor $\p_c \p_f \: \Set \to \Set$, where $p_c$ and $p_f$ are respectively the countable powerset functor and the finite powerset functor. In order to formalize this specification as a coalgebra on $\At \: \Lw \to \Set$, we need to lift the analysis from $\Set$ to $\prsh{\Lw}$. For this purpose, we consider liftings $\widehat{\p_c} \: \prsh{\Lw} \to \prsh{\Lw}$ and $\widehat{\p_f}\: \prsh{\Lw} \to \prsh{\Lw}$, defined on presheaves $\F \: \Lw \to \Set$ by precomposition respectively with $\p_c$ and $\p_f$. Then, we would like to fix \eqref{Eq:KomPow_termMatching} as the definition of the $n$-component $p^{\sharp}(n)$ of a natural transformation $p^{\sharp}\: \At \to \PP (\At)$, that is, a $\PP$-coalgebra on $\At$. The problem is that $p^{\sharp}$ does \emph{not} fulfill the naturality requirement, as shown by the following example.

\begin{example}\label{Ex:non_compositional} The LIST program, the two goals $\m{List}(x)$, $\m{List}(\m{Nil})$ and the substitution ${x\mapsto \m{Nil}}$.

\end{example}

In \cite{KomPowCALCO11} the authors overcome this difficulty by relaxing the naturality requirement. The presheaf $\At$ is re-defined as a functor $\widetilde{\At} \: \Lw \to \m{Poset}$ and $p^{\sharp}$ as a \emph{lax natural transformation} $\widetilde{p^{\sharp}} \: \widetilde{\At} \to \widetilde{\p_c}\widetilde{\p_c}(\At)$, where $\widetilde{\p_c}\widetilde{\p_f} \: \m{Lax}(\Lw,\m{Poset})\to \m{Lax}(\Lw,\m{Poset})$ is the extension of $\PP \: \prsh{\Lw} \to \prsh{\Lw}$ to $\m{Poset}$-valued functors. Then $\widetilde{p^{\sharp}}$ becomes a $\widetilde{\p_c}\widetilde{\p_c}$-coalgebra in the category $\m{Lax}(\Lw,\m{Poset})$ of locally ordered functors $\F: \Lw \to \m{Poset}$ and lax natural transformations.

We refer to \cite[Ch.4]{KomPowCALCO11} for further details. The lax approach supplies a coalgebra that meets the specification \label{Eq:KomPow_termMatching}. However, it has also introduce several shortcomings. Unlike the categories $\Set$ and $\prsh{\Lw}$, $\m{Lax}(\Lw,\m{Poset})$ is neither complete nor cocomplete, meaning that a cofree comonad on $\widetilde{\p_c}\widetilde{\p_c}$ cannot be retrieved through the standard constructions \ref{Constr:cofree_ground} and \ref{Constr:coalgComonad_ground} that were used in the ground case. Moreover, the category of $\widetilde{\p_c}\widetilde{\p_c}$-coalgebrae becomes problematic, because the commutativity property of coalgebra maps does not cohere well with the laxness of arrows in $\m{Lax}(\Lw,\m{Poset})$. These two issues force the formalization of non-ground logic program to use quite different (and more unnatural \fabio{unnatural...or even obscure?}) categorical tools than the ones employed for the ground case.

Even more significantly, the lax coalgebra map $\widetilde{p^{\sharp}}$ induces a semantics which is not \emph{compositional}. The same square of example \ref{Ex:non_compositional} still does not commute in the lax setting, meaning that the actions of applying a substitution and making a derivation step produce different results according to the order in which we perform them.

\section{A saturated semantics for Logic Programming}\label{SEC:SemLogProg}

Motivated by the issues which we have examined in the previous section, we propose a different approach to the semantics of non-ground programs, based on \emph{saturation} techniques [CIT,CIT].

XXXXXXXXXXXXXXXXXXXXXXXX

XXXXXXXXXXXXXXXXXXXXXXXX

For such purpose, we consider the following adjunction between presheaf categories.

$$\xymatrix{\prsh{\Lw} \ar@(ur,ul)[rr]^{\U} &\bot & \ar@(dl,dr)[ll]^{\K} \prsh{|\Lw|}}$$

The left adjoint $\U$ is the forgetful functor, given by precomposition with the inclusion functor
$\incl\: |\catC| \hookrightarrow \catC$. As shown in~\cite[X, Th. 1, Cor. 2]{mclane}, $\U$ has a right adjoint $\K\: \prsh{|\catC|}\to \prsh{\catC}$ sending each object of $\prsh{|\catC|}$ to its \emph{Right Kan Extension} along $\incl$.

\[\xymatrix{|\catC| \ar@{^{(}->}[r]^{\incl} \ar[d]_{\F}&  \catC \ar[ld]^{\K(\F)}\\
 \set}\]

Given the presheaf of atoms $\At \: \Lw \to \Set$ and some $n \in |\Lw|$, the unit $\eta_{\At}\: \At \to \K\U\At$ of the adjunction is defined as follows:
\begin{align*}
% \nonumber to remove numbering (before each equation)
  \eta_{\At} (n)\: \U \At(n) & \to \prod_{f \in \Lw[n,m]} \U \At (m) \\
  A & \mapsto \lambda f. \U \At(f)(A).
\end{align*}\fabio{Mi piacerebbe una notazione piu carina per gli elementi di $\prod$.}

The set $\eta_{\At} (n)$ represents the saturation of the goal $A$, i.e. it consists of all substitution instances $\U \At(f)(A) = \At(f)(A)$ of $A$, each indexed by the corresponding tuple of terms $f \in \Lw[n,m]$.

We now include in the picture the saturation on the program side. For such purpose, we consider the restriction of $\PP \: \prsh{\Lw} \to \prsh{\Lw}$ to an endofunctor in $\prsh{|\Lw|}$. When the context is unambiguous, this will be also denoted with $\PP$, the difference between $\Lw$ and $|\Lw|$ being that the latter has only identities as arrows.
Then we define a natural transformation $p^{\flat} \: \U \At \to \PP \U \At$ in $\prsh{|\Lw|}$ as follows:
\begin{align}\label{Eq:TermMatching}
% \nonumber to remove numbering (before each equation)
  p^{\flat}(n) &\: \U \At (n)  &&\to \PP \U \At (n) \nonumber \\
            &\: A              &&\mapsto \{ \{B_1,\dots,B_k\}\theta\ |\ H :- B_1,\dots,B_k \text{ is a clause of }\mb{P}\text{, } \nonumber \\
            &                  && A = (H \theta) \text{and }B_1\theta, \dots, B_k\theta \in \At(n)\}.&&
\end{align}

The definition of $p^{\flat}$ respects the specification given in \cite{KomPowCALCO11}, i.e. unification of a goal with clauses is restricted to the case of term matching. As observed in the introduction, $p^{\flat}$ would fail to be a natural transformation if defined in $\prsh{\Lw}$. However, the naturality requirement is trivially satisfied in $\prsh{|\Lw|}$, because there is no non-trivial arrow to test in $|\Lw|$.

We can now recover a natural transformation in $\prsh{\Lw}$ as follows:
\begin{eqnarray}\label{eq:SatCoalgebra}
% \nonumber to remove numbering (before each equation)
  \At \ \xrightarrow{\eta _{\At}} \ \K\U\At \ \xrightarrow{\K(p^{\flat})} \ \K \PP \U\At .
\end{eqnarray}
The natural transformation $\K(p^{\flat})$ in the equation \eqref{eq:SatCoalgebra} is defined as an `indexwise' application of $p^{\flat}$ on tuples from $\K\U\At$, that is:
\begin{align*}
% \nonumber to remove numbering (before each equation)
    \K(p^{\flat})(n) \: \K\U\At(n) & \to \K\PP \U\At(n) \\
                     <\dots,A_f,\dots>_{f\: n \to m}  & \mapsto <\dots,p^{\flat}(n)(A_f)_f,\dots>_{f\: n \to m}.
\end{align*}
Intuitively, $\K(p^{\flat})(n)$ models term matching between a goal $A \in \At(n)$ and the substitution instances of clauses in the program (the action of $p^{\flat}$), modulo the substitution instances of $A$ (the action of $\K$).

For the sequel, we use the abbreviation $\FS$ for the functor $\K \PP\U \: \prsh{\Lw} \to \prsh{\Lw}$. The coalgebra $\p^{\sharp} \: \At \to \FS(\At)$ is defined as the composition $\K(p^{\flat})\circ \eta_{\At}$. Observe that $\p^{\sharp}$ is indeed an arrow of $\prsh{\Lw}$: it satisfies the naturality requirement, since both $\K(p^{\flat})$ and $\eta_{\At}$ are natural transformations. In this way, we achieve that compositionality property that was precluded by the term-matching approach, as shown by the following rephrasing of example \ref{Ex:non_compositional}.

\begin{example} Example \ref{Ex:non_compositional} rephrased and eventually commuting.
\end{example}

Another benefit of saturated semantics is that the coalgebra $\p^{\sharp}$ `lives' in a (co)complete category which behaves (pointwise) as $\Set$. This allows to follow the same steps of the ground case, explicitly constructing a a coalgebra for the cofree comonad $\mb{C}(\FS)$ as a straightforward generalization of constructions \ref{Constr:cofree_ground} and \ref{Constr:coalgComonad_ground}. In this aim, we first need to show the following property.

\begin{proposition}\label{Prop:terminalForKPPU_converges} The terminal sequence for $\At \times \FS (-)$ converges to a terminal coalgebra. \end{proposition}
\begin{proof} By \cite[Th. 7]{Worrell99}, it suffices to prove that $\FS$ is an accessible mono-preserving functor. Since these properties are preserved by composition, we show them separately for each component of $\FS$:
\begin{itemize}
  \item $\K$ and $\U$ are a pair of adjoint functors between accessible categories, whence they are accessible themselves (\cite[Prop. 2.23]{adamek/rosicky:1994}). Moreover, they are both right adjoints: in particular, $\U$ is right adjoint to the left Kan extension along $i \: |\catC| \hookrightarrow \catC$. It follows that both preserve limits, whence they preserve monos.
  \item The functors $\widehat{\p_c}\: \prsh{|\Lw|} \to\prsh{|\Lw|}$ and $\widehat{\p_f}\: \prsh{|\Lw|} \to\prsh{|\Lw|}$ are defined as liftings from $\Set$ to $\prsh{|\Lw|}$ of $\p_ c \: \Set \to \Set$ and $\p_f \: \Set \to \Set$. As observed in construction \ref{Constr:cofree_ground}, $\p_c$ and $\p_f$ are both accessible functors on $\Set$ which also preserve pullbacks. Since (co)limits in presheaf categories are computed objectwise, this means that also $\widehat{\p_c}$ and $\widehat{\p_f}$ have these properties. In particular, preservation of pullbacks implies preservation of monos.
\end{itemize}
\end{proof}


\begin{construction}\label{Constr:cofree_sat} The terminal sequence for the functor $\At \times \FS (-) \: \prsh{\Lw} \to \prsh{\Lw}$ consists of a sequence of objects $X_{\alpha}$ and arrows $\delta_{\alpha}\: X_{\alpha+1} \to X_{\alpha}$, which are defined just as in construction \ref{Constr:cofree_ground}, with $\FS$ replacing $\p_f \p_f$.

By proposition \ref{Prop:terminalForKPPU_converges}, this sequence converges to a limit $X_{\gamma}$ such that $X_{\gamma} \cong X_{\gamma+1}$ and it is the carrier of the cofree $\FS$-coalgebra on $\At$.
\end{construction}

By accessibility of $\FS$, the \emph{cofree comonad} $\mb{C}(\FS)$ on $\FS$ exists and maps $\At$ into $X_{\gamma}$ given as in construction \ref{Constr:cofree_sat}. A $\mb{C}(\FS)$-coalgebra $\overline{p^{\sharp}} \: \At \to X_{\gamma}$ is defined as follows.

\begin{construction}\label{Constr:coalgComonad_sat} Let $\{p_{\alpha}\: \At \to X_{\alpha}\}_{\alpha \ls \gamma}$ be a cone on the terminal sequence of construction \ref{Constr:cofree_sat}, defined as in construction \ref{Constr:coalgComonad_ground} with $\FS$ and $p^{\sharp}$ replacing respectively $\p_f \p_f$ and $p^{\sharp}$. Analogously to the ground case, $X_{\gamma} = \mb{C}(\FS)(\At)$ yields a function $\overline{p^{\sharp}}\: \At \to X_{\gamma}$ which is a $\mb{C}(\p_f \p_f)$-coalgebra structure on $\At$.
\end{construction}



\begin{definition} Saturated derivation tree \end{definition}

\section{Desaturation}
\pippo{Io inizierei questa sezione dicendo che i coinductive derivation trees sono molto importanti, perche' ci permettono un algoritmo di risoluzione parallelo,
come quello mostrato da Power e Komendaskaya... Motivati da questo mostriamo un modo di ottenerli nel nostro framework.}
In this section we compare our notion of saturated derivation tree with the one of coinductive derivation tree.
The key observation is that the latter can be seen as a ``desaturated'' version of the former, where only the branching given by term matching
is taken into account. Categorically, we will formalize the space of coinductive derivation trees as a cofree coalgebra in
$\prsh{|\Lw|}$.
Then we will provide a natural transformation $\overline{\m{ds}}$ in $\prsh{|\Lw|}$, which maps the saturated derivation tree $\mb{T}_A$ of an atom $A$
into the coinductive derivation tree $\mb{T}^{\prime}_A$ of $A$, obtained by desaturation of $\mb{T}_A$.


\vspace{7cm}
For such purpose, the kind of behavior we are interested is the one given by the $\PP$-coalgebra $(\U\At,\m{tm})$,
which we already considered in section \ref{SEC:SemLogProg}.
\pippo{Section \ref{SEC:SemLogProg}} As before, we provide the cofree comonad $\mb{C}(\PP)\: \coalg{\PP} \to \coalg{\PP}$ through a limit construction. This consists of sequences of objects $Y_{\alpha}$ and arrows $\lambda_{\alpha}\: Y_{\alpha+1} \to Y_{\alpha}$, defined by induction on $\alpha$.
 \begin{eqnarray*}
 % \nonumber to remove numbering (before each equation)
   Y_{\alpha} &:=& \left\{
	\begin{array}{ll}
        \U \At & \alpha = 0 \\
		\U \At \times \PP (Y_{\beta}) & \alpha \mbox{ is a successor ordinal } \beta +1
        % \\  \m{Lim}_{\beta \ls \alpha}\ X_{\beta} & \alpha \mbox{ is a limit ordinal}
	\end{array}
\right.\\
  \lambda_{\alpha} &:=& \left\{
	\begin{array}{ll}
        \pi_1 & \alpha = 0 \\
		\m{Id}_{\U\At} \times \PP (\lambda_{\beta}) & \alpha \mbox{ is a successor ordinal } \beta +1
	\end{array}
\right.\\
 \end{eqnarray*}
The case of $\alpha$ a limit ordinal is handled as expected. By Lemma \ref{LM:shifting_lims_pres}
the functor $\PP$ is accessible and preserves monos; it follows that the sequence converges to some
$Y_{\zeta} \in \prsh{|\Lw|}$, constituting the carrier of the $\PP$-coalgebra $\mb{C}(\PP)(\U\At, \m{tm})$.


\pippo{Secondo me $ds_\alpha$ e' definito male: $(\PP (\m{ds}_{\beta})$ ha come dominio $\PP \U X_{\gamma}$ e non $\PP \U X_{\beta}$.}
Our next step is to define a cone $\{{\m{ds}}_{\alpha}\: \U(X_{\gamma}) \to Y_{\alpha} \}_{\alpha\ls\zeta}$,
where $X_{\gamma}$ is the carrier of the $\FS$-coalgebra $\mb{C}(\FS)(\At, \m{rs})$ in the category $\prsh{\Lw}$.
For this purpose, we consider the image of the final sequence for $\mb{C}(\FS)(\At, \m{rs})$ under the forgetful functor
$\U\: \prsh{\Lw} \to \prsh{|\Lw|}$.
This gives a cone $\{\U(q_{\alpha})\: \U(X_{\gamma}) \to \U(X_{\alpha}) \}_{\alpha\ls\gamma}$ having $\U(X_{\gamma})$ as vertex.
Then we introduce a family of natural transformations $\{\sigma_{\alpha}\: \U(X_{\alpha}) \to Y_{\alpha} \}_{\alpha\ls\gamma}$ as follows.
 \begin{eqnarray}   \label{eq:desat_cone_sigma}
 % \nonumber to remove numbering (before each equation)
   \sigma_{\alpha} &:=& \left\{
	\begin{array}{ll}
        \m{Id}_{\U \At} & \alpha = 0 \\
		\m{Id}_{\U \At} \times \big(\PP (\m{ds}_{\beta}) \circ \epsilon_{\PP \U X_{\beta}}\big) & \alpha \mbox{ is a succ. ord. } \beta +1
	\end{array}
\right.
 \end{eqnarray}
Here $\epsilon_{\PP \U X_{\beta}}\: \U\K\PP \U X_{\beta} \to \PP \U X_{\beta}$ is the instantiation at $\PP \U X_{\beta}$ of the counit of
the adjunction $\U \dashv \K$. Concerning the successor case, observe that
$\m{Id}_{\U \At} \times \big(\PP (\m{ds}_{\beta}) \circ \epsilon_{\PP \U X_{\beta}}\big)$
is in fact an arrow from $\U\At \times \U\K\PP\U X_{\beta}$ to $Y_{\beta+1} = \U\At \times \PP Y_{\beta}$. However, the former is isomorphic to $\U (X_{\beta+1}) = \U (\At \times \K\PP\U X_{\beta})$, because $\U$ is a right adjoint (namely to the left Kan extension along $i \: |\Lw| \hookrightarrow \Lw$) and thence it preserves limits.

For $\alpha$ a limit ordinal, a natural transformation $\sigma_{\alpha}\: \U(X_{\alpha}) \to Y_{\alpha}$ is provided by the universal mapping property of $Y_{\alpha}$. The limit case is well defined: for each limit ordinal $\alpha$, we can show that $\lambda_{\beta} \circ {\sigma}_{\beta +1}  = \U\delta_{\beta}{\sigma}_{\beta}$ for every $\beta \ls \alpha$.

\[\xymatrix{
& \U X_{\alpha} \ar[rr]& & Y_{\alpha}\\
\U X_{\gamma} \ar[ru]^{\U q_{\alpha}} \ar[rd]_{\U q_{\alpha +1}} \\
& \U X_{\alpha +1} \ar[rr] \ar[uu]^{\U\delta_{\alpha}} & & Y_{\alpha +1} \ar[uu]_{\lambda_{\alpha}}\\
}
\]

\begin{todo}Insert proof of this commutativity property. \end{todo}

Finally the definition of our cone $\{{\m{ds}}_{\alpha}\: \U(X_{\gamma}) \to Y_{\alpha} \}_{\alpha\ls\zeta}$ over the final sequence for $\PP$ is given as follows:
 \begin{eqnarray}   \label{eq:desat_cone}
 % \nonumber to remove numbering (before each equation)
   \m{ds}_{\alpha} &:=& \sigma_{\alpha} \circ \U(q_{\alpha}).
 \end{eqnarray}

\pippo{Forse la spiegazione e' piu' chiara se si introduce prima il quadrato e poi il triangolo...}

Definition \eqref{eq:desat_cone} determines a natural transformation $\m{ds}_{\alpha}\: U(X_{\gamma}) \to Y_{\alpha}$ for all $\alpha \ls \gamma$.
In fact $\zeta$ is smaller than $\gamma$, \pippo{La footnote e' davvero molto confusa}because the final sequence for $\K\PP\U$ cannot converge in less steps than the one for $\PP$\footnote{In fact, even if $\gamma$ was smaller than $\zeta$, we know that $X_{\gamma}$ is isomorphic to $X_{\chi}$ for all ordinal $\chi \gr \gamma$. Then in particular $U(X_{\zeta}) \cong U(X_{\gamma})$ would be the vertex of a cone defined as in \eqref{eq:desat_cone} for all $\alpha < \zeta$.}. It follows that \eqref{eq:desat_cone} defines an arrow $\m{ds}_{\alpha}\: U(X_{\gamma}) \to Y_{\alpha}$ for all $\alpha \ls \zeta$.

What remains to show is that $\{\m{ds}_{\alpha}\: \U(X_{\gamma}) \to Y_{\alpha} \}_{\alpha\ls\zeta}$ is indeed a cone: this follows by commutativity of the squares determined by the $\sigma_{\alpha}$s and the triangles determined by the $\U(q_{\alpha})$, as shown above.

The universal mapping property of $Y_{\zeta}$ provides an arrow $\overline{\m{ds}} \: X_{\gamma} \to Y_{\zeta}$.
Given an atom $A \in \At(n)$, we consider the application of $\overline{\m{ds}}$ to its saturated derivation tree
$\mb{T}_G \in X_{\gamma}(n) = U(X_{\gamma})(n)$.

\begin{todo} Intuition on the structure of $\overline{\m{ds}}(n)(\mb{T}_G)$, on the base of the commuting property of $\overline{\m{ds}}$. \end{todo}

\begin{proposition} Let $G \in \At(n)$ be a goal and $\mb{T}_G \in X_{\gamma}(n) = U(X_{\gamma})(n)$ its saturated derivation tree. Then $\overline{\m{ds}}(n)(\mb{T}_G)$ is the coinductive derivation tree for $G$.
\end{proposition}




\section{Bonus tracks?}


\bibliographystyle{alpha}
\bibliography{catBib}

\end{document}
























%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% RUBBISH %%%%%%%%%%%%%55
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%% SECTION 2 %%%%%%%%%%%%%
%A naive attempt to accommodate both desiderata is to model $p^{\sharp}$ as a sort of `and-or parallel implementation' of the standard $\SLD$ resolution algorithm [CIT]. Given an atom $A \in \At(n)$ for some $n \in |\Lw|$, the function $p^{\sharp}(n)$ is given as follows:
% \begin{eqnarray}\label{eq:OneStepUnification}
%    \nonumber
%    A\ \mapsto\ \{ \{\theta(B_1),\dots,\theta(B_k)\} & \mid & H :- B_1,\dots,B_k \text{ is a clause of }\mb{P}\\
%                                         &      &   \text{and }\theta \text{ is the mgu of }A \text{ and }H\}.
% \end{eqnarray}
%This means that each component $p^{\sharp}(n)$ can be assigned a type $\At(n) \to \p_f \p_f(\At)$. Then $p^{\sharp}$ is a natural transformation of This amounts to define $p^{\sharp}$ as a natural transformation from $\At$ to $\PP (\At)$, where $\widehat{\p _c}$ and $\widehat{\p _f}$ are the $|\Lw|$-liftings respectively of the countable powerset functor $\p_c \: \Set \to \Set$ and the finite powerset functor $\p_f \: \Set \to \Set$, defined by precomposition.
